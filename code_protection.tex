\section{Overview of Our Approach}\label{sec:overview}
To address the problem of cumulative attacks, we want to introduce a certain
degree of diversity and uncertainty into program execution. This is achieved
through using a diversified scheduling structure (Section~\ref {sec:dvs}) and
multiple VMs (Section~\ref {sec:mvm}). Like other VM-based protection schemes,
\DSVMP focuses on protecting critical code regions but not the entire program to minimize the runtime overhead.
Figure~\ref{fig:Fig.overview} depicts the system architecture of \DSVMP.
Code protection of \DSVMP follows several steps described as follows.

\begin{figure}[!t]
  \centering
  % Requires \usepackage{graphicx}
  \includegraphics[width=0.7\columnwidth]{figure/figoverview.pdf}
  \caption{Offline code protection process. \DSVMP takes in a program binary. For each protected code region, it translates native instructions into bytecodes. Next, it generates multiple bytecode handlers that are semantically equivalent but implemented in different ways. It then generates the corresponding driver-data and multiple VMs. Finally, the generated VMs and associated components will be inserted into the program binary and fills the original code region with junk instructions.}\label{fig:Fig.overview}
  %\vspace{-5mm}
\end{figure}

\paragraph*{Code translation} \DSVMP takes in a compiled program binary and
does not require having access to the source code. Code segments need to be
protected are given by providing the symbolic name of the functions or a pair
of the start and end address in the binary file. The code segments are
firstly converted into native machine assembly code (e.g. x86 instructions)
using a disassembler (Step \ding{182}), which will then be mapped into a set of virtual instructions (Step \ding{183}).

\paragraph*{Diversifying}
As a departure from prior work on VM-based code obfuscation, \DSVMP employs multiple VM instruction scheduling policies
where each scheduler can have multiple dispatchers and handlers. It provides a set of handlers 
that are semantically equivalent but  are implemented in different ways for a single virtual instruction. 
Thus, the scheduler can dynamically determine at runtime which of the handlers is used to interpret a virtual instruction. 
Multiple handlers are generated by applying obfuscation to a set of seed handlers (Step \ding{184}).
The way the handlers are obfuscated could be different for different code regions.
\DSVMP uses a multi-VM schemes with more than one VM implementation. 
Therefore, each handler will be obfuscated for each VM by using the deformation engine \FIXME{What is the deformation engine and what is VMNum?}, resulting in $n$ (the number of VMs) sets of semantically equivalent handlers with different implementations and control flows (Step \ding{185}). 
Next, the virtual instructions will be encoded into different sets of bytecode for each VM. In our current implementation, the virtual instructions
are encoded into two different sets of bytecode for each VM implementation (Section~\ref {sec:mbd}), i.e. $2*n$ sets of bytecode for $VMNum$ VMs (Step \ding{186}). Subsequently, \DSVMP constructs multiple VMs, where each VM contains one set of handlers (where a virtual instruction
can be interpreted by multiple handlers), and two sets of bytecodes (Step \ding{187}).

\paragraph*{Code generation}
Finally, a new section will be inserted into the program binary, which contains $VMNum$ VMs and their components such as dispatchers, VMContext etc. It also fills the original code region with junk instructions (Step \ding{188}).

This is an overview of our approach. We describe the implementation of \DSVMP in more details in the following sections.
