%%
%% Copyright 2007, 2008, 2009 Elsevier Ltd
%%
%% This file is part of the 'Elsarticle Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%%

%% Template article for Elsevier's document class `elsarticle'
%% with numbered style bibliographic references
%% SP 2008/03/01
%%
%%
%%
%% $Id: elsarticle-template-num.tex 4 2009-10-24 08:22:58Z rishi $
%%
%%
\documentclass[preprint,12pt,3p]{elsarticle}

\usepackage{color}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{xspace}
\usepackage[colorlinks,bookmarksopen,bookmarksnumbered,citecolor=red,urlcolor=red]{hyperref}
\usepackage{booktabs}

\newcommand{\DSVMP}{\textsc{Dsvmp}\xspace}
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
\newcommand\FIXME[1]{\textcolor{red}{FIX:}\textcolor{red}{#1}}
\lstdefinelanguage
   [x64]{Assembler}     % add a "x64" dialect of Assembler
   [x86masm]{Assembler} % based on the "x86masm" dialect
   % with these extra keywords:
   {morekeywords={CDQE,CQO,CMPSQ,CMPXCHG16B,JRCXZ,LODSQ,MOVSXD, %
                  POPFQ,PUSHFQ,SCASQ,STOSQ,IRETQ,RDTSCP,SWAPGS, %
                  rax,rdx,rcx,rbx,rsi,rdi,rsp,rbp, %
                  r8,r8d,r8w,r8b,r9,r9d,r9w,r9b}} % etc
\lstset{language=[x64]Assembler}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

%% Use the option review to obtain double line spacing
%% \documentclass[preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}

%% if you use PostScript figures in your article
%% use the graphics package for simple commands
%% \usepackage{graphics}
%% or use the graphicx package for more complicated commands
%% \usepackage{graphicx}
%% or use the epsfig package if you prefer to use the old commands
%% \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
%% \usepackage{lineno}

%% natbib.sty is loaded by default. However, natbib options can be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%
%% \biboptions{comma,round}

% \biboptions{}


\journal{Computers \& Security}

\begin{document}

\begin{frontmatter}

\title{
Enhance Virtual-Machine-Based Code Obfuscation Security through Dynamic Bytecode Scheduling
\footnote{
Extension of Conference Paper: a preliminary version of this article entitled ``Exploiting Dynamic Scheduling for VM-Based Code Obfuscation" by K. Kuang et el. appeared in the 15th IEEE International Conference on Trust, Security and
Privacy in Computing and Communications(TrustCom), 2016~\cite{kuang2016exploiting}. The extended version makes the following additional contributions over the conference paper: (1) it provides a more detailed description of the background and threat model (Section~\ref{sec:bak} and~\ref{sec:attack}); (2) it describes how the virtual interpreter dynamically changes the execution path at runtime using an algorithmic model (Section~\ref{sec:mvm-2} and Algorithm~\ref{Alg:VMcore-work}); (3) it provides new experimental results to evaluate the overhead of the proposed technique, providing new insights of the approach (Section~\ref{sec:benchmarktest}); (4) it adds a new experiment to evaluate the diversity of the protected structure at runtime (Section~\ref{sec:s-d}); (5) it includes new results to compare the proposed approach against two commercial VM protection systems, Code Virtualizer and VMProtect (Section~\ref{sec:comparetest}).
}
}
%\tnotetext[label0]{This is only an example}

%\author[label1,label2]{Author One\corref{cor1}\fnref{label3}}
\author[label1]{Kaiyuan Kuang}
\address[label1]{School of Information Science and Technology, Northwest University, China.}
\address[label2]{School of Computing and Communications, Lancaster University, UK}%\fnref{label4}}

\cortext[cor1]{Corresponding author. Email address: zytang@nwu.edu.cn}

\ead{kky@stumail.nwu.edu.cn}


\author[label1]{Zhanyong Tang\corref{cor1}}
\ead{zytang@nwu.edu.cn}

\author[label1]{Dingyi Fang}
\ead{dyf@nwu.edu.cn}

\author[label1]{Xiaojiang Chen}
\ead{xjchen@nwu.edu.cn}

\author[label2]{Zheng Wang}
\ead{z.wang@lancaster.ac.uk}

\input{abstract}

\begin{keyword}
Code virtualization \sep Code Obfuscation \sep Dynamic cumulative attack
\end{keyword}

\end{frontmatter}

%%
%% Start line numbering here if you want
%%
% \linenumbers

%% main text
\input{intro}
\input{background}



\input{attack_model}
\input{code_protection}


\section{\DSVMP Scheduling Structure}\label{sec:dvs}

The \DSVMP VM scheduler uses multiple dispatchers to determine which bytecode instruction should be interpreted at given time.
A unique design of \DSVMP is that the dispatcher used to schedule bytecode handlers will be dynamically changed at execution time. To further increase the diversity of program behaviour, \DSVMP also uses multiple bytecode instruction sets and bytecode handlers.

\subsection{Multiple Bytecode Handlers}\label{sec:mb}

%\begin{figure}[t!]
%\scriptsize
%\begin{lstlisting}
%lods byte/word/dword ptr ds:[esi]
%... ...
%push eax
%rdtsc                    ;------------------------
%mov ecx,2
%div ecx                  ;structure control unit
%cmp edx,0
%jz label                 ;------------------------
%lods byte ptr ds:[esi]
%... ...                  ; to the next handler
%add dword ptr ds:[edi+0x60],eax
%jmp dword ptr ds:[edi+0x60]
%label: push ebx          ;------------------------
%div bl
%movzx eax,AH             ; return to a dispatcher
%add eax,9dH
%... ...
%\end{lstlisting}
%\vspace{-2mm}
%\caption{Each bytecode handler has a control unit that randomly determines whether the control after exiting the handler should be given to a dispatcher or an alternative bytecode handler. }
%\vspace{-5mm}
%\label{fig:newhandler}
%\end{figure}
\begin{figure}[!t]
  \centering
  % Requires \usepackage{graphicx}
  \includegraphics[width=0.9\columnwidth]{figure/fighandler.pdf}
  %\vspace{-1mm}
  \caption{The execution flow of the new handler, each bytecode handler has a control unit that randomly determines whether the control after exiting the handler should be given to a dispatcher or an alternative bytecode handler.}\label{fig:newhandler}
  %\vspace{-3mm}
\end{figure}

In classical VM-based code obfuscation, a single dispatcher is responsible for fetching a bytecode instruction and
determining which bytecode handler should be used to interpret the instruction by checking the opcode of the bytecode
instruction.
Because each bytecode instruction
is decoded by a fixed handler set, an adversary can easily work out the mapping from an opcode to its
handler. From the mapping, the adversary can correlate the native machine code to each bytecode to analyze the
program behavior and  the logic structure.

To address this issue, for each bytecode handler, we use obfuscation techniques to automatically generate a number of alternative implementations which all
produce an equivalent output for the same input instruction. Different implementations, however,
are programmed in different ways using e.g. different control flows, data structures or obfuscation methods.

To control the program execution path, we insert a control unit at the end of each bytecode handler.
Before exiting a bytecode handler, the control unit randomly determines whether the control should be given back to a dispatcher or
another handler.
Figure~\ref{fig:newhandler} shows an example of the control unit of a \DSVMP bytecode handler.
When the main function of the handler is finished, the control unit randomly determines to execute the code in different branch.
At the first branch, the ``\texttt{lods}" (a load operand in the x86 assembly) instruction fetch an offset value from \emph{Offset Bytecode} to calculate the address of the nest bytecode handler and jump to execute it.
By contrast, the instruction at another branch will return to a dispatcher.
Figure~\ref{fig:Fig.dh} shows two different dynamic scheduling results, under the action of the control unit, a handler can either be invoked by a dispatcher or another handler.
The \emph{Offset Bytecode} here is different from the usual standard bytecode, which is designed to drive the handler's dispatch function, and we will describe in detail in the next section.

\begin{figure}[!t]
  \centering
  % Requires \usepackage{graphicx}
  \includegraphics[width=0.7\columnwidth]{figure/figdh.pdf}
  %\vspace{-1mm}
  \caption{Our approach employes multiple dispatchers together with a control unit to schedule the handlers. In this example, the type of handlers and the order for invoking the handlers could be different across execution runs. The ``XX" in bytecode refers to the parameters. Underlined two bytecodes is handler43 encoding results in two types of \emph{Bytecode} respectively}\label{fig:Fig.dh}
  %\vspace{-3mm}
\end{figure}

\subsection{Multiple Bytecode Formats and Dispatchers}\label{sec:mbd}
\paragraph{Bytecode Formats} Using VM-based obfuscation, the protected code regions will be translated into virtual
instructions and stored in a bytcode format. A handler will
be chosen to decode the bytecode instruction to translate it
to native machine code at runtime.  In classical VM-based
code obfuscation approaches, there is one-one mapping from a
bytecode opcode to a handler, i.e. the bytecode opcode
determines which handler to be used.
Having multiple bytecode instruction sets for different code regions of a target program can provide stronger protection.
By doing so, the same opcode from different code region will have
different semantic meaning as the same opcode from different regions can be mapped into different handlers and hence different
native machine code. For this reason, the virtual instructions
of different code regions will be stored in different bytecode formats.

Our current implementation uses two bytecode formats for each VM, namely \emph{Standard Bytecode} and
\emph{Offset Bytecode}. Additional bytecode formats can be easily added to our system. Here, \emph{Standard Bytecode} is a
standard bytecode format where each bytecode consists of the virtual instruction's opcode (a ID indicates which handler
should use to interpret the virtual instruction) and their operand (if they have), at rumtime, dispatcher will fetch the bytecode from it. \emph{Offset Bytecode} uses a different encoding scheme, which is fetched by the handler's control unit.
Each \emph{Offset Bytecode} consists of the offset IDs of two adjacent handlers (for example, when handler21 direct transfer control to handler43 in Figure~\ref{fig:Fig.dh}, fetched offset bytecode is ``22") and their operands respectively.
Recall that a control unit is inserted to the end of each handler to determine whether the control should be
given back to the dispatcher or another handler.  Before exiting the handler, if the control unit chooses to execute
the next handler, it will fetch the corresponding offset value from \emph{Offset Bytecode}.

\paragraph{Dispatchers} \DSVMP also provides multiple dispatchers to further increase the diversity of program execution.
As an example, considering Figure~\ref{fig:Fig.dh} which shows two possible program execution paths using
three dispatchers within a single VM. As can be seen from the diagram,
each time you can choose a different dispatcher to schedule the handler,
coupled with the control unit, a handler can either be invoked by a dispatcher or another handler;
the type of handlers to be invoked could be different in two different execution runs.
As a result, knowledge about the program control flow extracted from the first run does not apply to the second one.


\section{Multiple VMs}\label{sec:mvm}
In contrast to classical VM-based obfuscation approaches that uses a single VM (\emph{termed SVM}), \DSVMP uses multiple VMs.
Multiple VMs offer different sets handlers and bytecode instruction sets. Under such settings,
bytecode instructions can be scheduled from different VMs and a virtual instruction can be interpreted by more than one handler.
Therefore, there will be more than one mapping from a bytecode instruction to handlers.
Together with the above multiple scheduling approach, multiple VMs can further increase the diversity and uncertainly of program execution.

%\begin{figure}[!t]
%  \centering
% % Requires \usepackage{graphicx}
%  \includegraphics[width=0.6\columnwidth]{figure/figmvm.pdf}\\
%  \caption{The structure of multiple VMs. Each VM has one set of unique handlers and two sets of bytecode instructions, \emph{DriverDataSetN1} and \emph{DriverDataSetN2}.}\label{fig:Fig.mvm}
 %\vspace{-2mm}
%\end{figure}


\subsection{Switching between Multiple VMs}
The number of VMs to use is a  parameter that can be configured by the user. This number can vary
depending on the target program to be protected, and the trade-off between the protection strength and runtime overhead.
As described in Section~\ref{sec:mbd}, we generate a set of handlers for each VM so that
we have $n$ different sets of handlers for $n$ VMs. Our current implementation
also translates the virtual instructions of each handler set to stored as two different sets of bytecode.
Different bytecodes will have different semantics in different VMs. Therefore,
there have more than a bytecode could be translated by different handlers in different VMs.

\begin{figure}[t!]
\scriptsize
\begin{lstlisting}
push edx                           ;------------------------
rdtsc
xor edx,edx
div dword ptr ds:[edi+0x58]        ;VM switching unit
mov eax,edx
sub edx,dword ptr ds:[edi+0x50]
je label                           ;------------------------
imul edx,dword ptr ds:[edi+0x54]   ;Modify the VM PC and
add esi,edx                        ;save the current VM ID
mov dword ptr ds:[edi+0x50],eax
label: lods byte ptr ds:[esi]      ;------------------------
... ...                            ;Fetch the bytecode and
movzx eax,al                       ;dispatch a Handler
add eax,edx                        ;to interpret it
pop edx
jmp dword ptr ds:[edi+eax*4+0x60]
\end{lstlisting}
%\vspace{-2mm}
\caption{The new dispatcher has a VM switch unit that can randomly select one of the multiple VMs to continue scheduling handler.}
%\vspace{-5mm}
\label{fig:mvmswitcher}
\end{figure}

Our system dynamically determines which VM to use at runtime.
This is done through altering the structure of the instruction dispatcher which decides which VM to use at runtime.
Figure~\ref{fig:mvmswitcher} shows an example of the new dispatcher structure,
which has a VM switch unit that can randomly select one of the multiple VMs to continue scheduling handler.
To do so, The switching unit first randomly selects one VM among the multiple VMs (lines 1-7),
and then modifies the virtual program counter (\texttt{VM PC}) to point to the target VM (lines 8-10).
%\FIXME{The assembly code is impossible to understand. Could you put a pseudo-code (or a diagram) along slide the assembly code to explain how the value of ESI is changed?}
Our implementation uses the x86 \texttt{ESI} register as a \texttt{VM PC} to store the
address of the next bytecode instruction. Other registers can also be used for this purpose.
Finally, the dispatcher fetches a bytecode according to the modified \texttt{VM PC} and
dispatches the handler to interpret it in the corresponding VM (lines 11-16).
The VM, the set of bytecode handlers and bytecode instructions will be randomly switched
across different code regions in both a single execution and across different program runs.

\subsection{The VM Scheduling Process}\label{sec:mvm-2}
%Our goal is to provide runtime scheduling diversity to enhance code virtualization protection.
%As described in the previous section, we use the flexible handler scheduling and multiple VMs to achieve this goal,
%and in order to achieve a new scheduling approach, we have further improved the virtual interpreter,
%respectively, added the following special structural unit:

Our dynamic scheduling is achieved through two control units: (1) a structure control unit
to randomly determine whether the execution control should be given to a dispatcher or another bytecode handler,
(2) a VM switching unit to randomly select a VM to use. Having these two control units to switch
the execution path of virtual instruction interpretation can greatly increase the
diversity of the program behavior when compared to existing approaches  that
have a single, fixed scheduling structure.

\begin{algorithm}[t!]
\caption{Virtual Interpreter's Work Flow\label{Alg:VMcore-work}}
\begin{algorithmic}[1]
%\REQUIRE
%\ENSURE
\STATE \texttt{VMInit}
\STATE Switcher selects a VM randomly
\STATE Fetch a bytecode from \emph{Standard Bytecode} in current VM
\WHILE {$ bytecode \neq \emptyset$}
\STATE Decode the bytecode
\STATE Select a handler to interpreter the bytecode
\STATE i = handler\_exit\_address
\IF {i == \texttt{dispatcher}}
\STATE Select a dispatcher randomly
\STATE Switching unit selects a VM randomly
\STATE Fetch the next bytecode from \emph{Standard Bytecode} from the selected VM
\ELSE [i == \texttt{handler}]
\STATE Fetch the next bytecode from \emph{Offset Bytecode} in the current VM
\ENDIF
\ENDWHILE
\STATE \texttt{VMExit}
\end{algorithmic}
\end{algorithm}

Our dynamic scheduling scheme is described in Algorithm~\ref{Alg:VMcore-work}. Bytecodes of a code region will
be executed one after one in sequential order.
The virtual interpreter fetchs a bytecode from \emph{Standard Bytecode} and dispatchs a handler to interpret the bytecode (lines 5-6).
After executing the bytecode, the control unit will randomly decide whether the control should be given back to a
bytecode dispatcher or a VM handler (line 7). If the control is given back to a bytecode dispatcher (lines 8-11), a
dispatcher and a VM will be randomly chosen to execute a bytecode from \emph{Standard Bytecode}. If the control is directed
to another bytecode handler (lines 12-13),  the program will execute the next bytecode from \emph{Offset Bytecode} .
The process continues until all the bytecodes of the protected code region
have been executed.


\input{example}

\section{Security Strength Analysis}\label{sec:s-eva}
This section analyzes the security strength provided by \DSVMP. We first analyze the number of possible execution paths. Then we discuss the diversity of code structures.


\subsection{Program execution paths}
Recall that our design goal is to increase the diversity of program execution,
so that in different runts the protected region will not follow a single execution path across runs.
In this analysis, we assume there are 10 different dispatchers. This number matches the current implementation of \DSVMP.
We use the example presented in Section~\ref{sec:case} as a case study.
In this example, \emph{Standard Bytecode} has 103 bytes of data.
They contain a total of 78 handler serial numbers. In this analysis, we exclude the last handler because of it is used to exit the VM.
This leave us 77 handlers where each handler can lead to 11 different execution paths.
This is because at the end of executing each handler, a control unit will determine whether the control
should be given to another handler or one of the 10 dispatchers (see Section~\ref{sec:mb}) -- 11 possibilities in total.

In combination, these options give $11^{77}$ possible execution paths for each protected code region.
Therefore, the probability, $p$, for a protected code region to follow the same execution path across
different runs is $p= \frac{1}{{{{11}^{77}}}}$,
%\[p= \frac{1}{{{{11}^{77}}}}\]
a very small number.
Bear in mind that so far we have assumed that the protection scheme uses just one VM.
The multi-VM strategy employed by \DSVMP further increases the number of possible execution paths.
In fact, the more dispatchers and VMs are, the greater number of possible execution paths will be.
The current \DSVMP implementation provides five different VMs. Together with the multiple dispatchers
and bytecode instruction straggles, for the setting used in this section, \DSVMP gives a single code region
$11^{385}$ possible execution paths. Given the massive number of choices, it will be rare for
a protected code region to take the same execution path across different runs.




\subsection{Code structures}
Having a diverse code structure is key to prevent an adversary from reusing knowledge obtained from other software to perform attacks. In other words,
we would like obfuscated program's code structures to be as much dissimilar from the original program's as possible.


Blietz \emph{et al.}~\cite{18blietz2006software} proposed a method to measure the similarity of program structures,
using control flow information such as the number of branches and back blocks, the nesting level of the code etc.
We draw lessons from this method to analyze code structures for programs protected using \DSVMP.
We use a number of metrics to describe program code structures. These metrics are:

\begin{itemize}
\item \texttt{NodeNum}: the number of basic blocks of the protected region.
\item \texttt{BranchNum}: the number of basic blocks where the last instruction is a conditional jump instruction.
\item $DR(Vi)$: the number of in and out instructions for the basic block, \emph{Vi}. This metric is defined as $DR(Vi) = {D_{in}}(Vi) + {D_{out}}(Vi)$ where ${D_{out}}\left( {Vi} \right)$ refers to the out-degree and ${D_{in}}\left( {Vi} \right)$ refers to the in-degree and they mean the number of arcs that start or end at $Vi$.
\item $DF(Vi)$: the data flow relationship of basic block, \emph{Vi}. This is used to measure the frequency of \emph{Vi}'s information exchange. It is defined as $DF\left( {Vi} \right){\rm{ }} = {\rm{ }}Flo{w_{in}}(Vi) + Flo{w_{out}}(Vi)$, where $Flo{w_{in}}$ is the number of reading instruction in \emph{Vi} and $Flo{w_{out}}$ is the number of writing instruction in \emph{Vi}.
\end{itemize}


\begin{table*}[!t]
\scriptsize
\begin{center}
\caption{The relevant information about the program\label{tab:Tab.2}}
{\tabcolsep8pt\begin{tabular}{@{}clccccc@{}}
\toprule
  \multicolumn{2}{c}{\textbf{Basic info of program}} & \multicolumn{5}{c}{\textbf{Info of protected-software}} \\

  \textbf{program} & \textbf{key code segment} & \textbf{program} & \textbf{Node Num} & \textbf{Branch Num} &
  $\sum\limits_{i = 0}^{i < n}{DR(i)}$ & $\sum\limits_{i = 0}^{i < n}{DF(i)}$\\
\midrule
  A & \tabincell{l}{\texttt{mov eax,ebx}\\ \texttt{sub eax,03}} & A' & 23 & 5 & 46 & 18\\

  B & \tabincell{l}{\texttt{pop eax}\\ \texttt{add eax,ebx}} & B' & 48 & 9 & 96 & 36\\
\bottomrule
\end{tabular}}{
\scriptsize\\Notes: In the table, the number of \texttt{n} which in $\sum\limits_{i = 0}^{i < n}{DR(i)}$
and $\sum\limits_{i = 0}^{i < n}{DF(i)}$ are equal to the \texttt{NodeNum}.}
\end{center}
\end{table*}

\subsubsection{Example}
Table~\ref{tab:Tab.2} gives two code regions for protection. These  two code snippets have very similar structures because they have just one basic block and no branches.
As can be seen from the table, the code transformation of \DSVMP leads to significantly different metric values. This indicates the transformed code segments have distinct structures.
The metric value calculation is described as follows.

We use the following formula to quantify the code structure information, $X$, after code obfuscation.
\[\begin{array}{l}
 SInfo{r_{X}} = NodeNu{m_{X}} + BranchNu{m_{X}} + \sum\limits_{i = 0}^{i < n} {(DR(i) + DF(i))}
 \end{array}\]

Applying this formula to the transformed code segments, A' and  B', listed in Table~\ref{tab:Tab.2},  we get :
\[\begin{array}{l}
 SInfo{r_{A'}} = NodeNu{m_{A'}} + BranchNu{m_{A'}} + \sum\limits_{i = 0}^{i < n} {(DR(i) + DF(i))} \\
                                        = 23 + 5 + (46 + 18)\\
                                        = 92 \\
 SInfo{r_{B'}} = NodeNu{m_{B'}} + BranchNu{m_{B'}} + \sum\limits_{i = 0}^{i < m} {(DR(i) + DF(i))}  \\
                                        = 48 + 9 + (96 + 36)\\
                                        =  189
\end{array}\]

where $n=NodeNu{m_{A'}}$ and $m=NodeNu{m_{B'}}$.
From $SInfo{r_{A'}}$ and $SInfo{r_{B'}}$,
we can calculate the similarity $SDiff$, for two code structure, A' and B' as:
\begin{align*}
SDiff = \frac{{|SInfo{r_{A'}} - SInfo{r_{B'}}|}}{{SInfo{r_{A'}} + SInfo{r_{B'}}}}\;{\kern 1pt}  = \frac{{97}}{{281}} = 34.5\% \end{align*}

Therefore, the quantified code structure similarity between A' and B' is  34.5\%.
This example shows that \DSVMP can significantly increase the dissimilarity of code structures even for simple code segments.
We also observe that the similarity between transformed code regions drops significantly
as the complexity of original code segments increases.


\section{Performance Evaluation}\label{sec:p-eva}
We evaluate \DSVMP using fix  applications
and compare it against two commercial VM-based protection systems.

\subsection{Evaluation Platform and Benchmarks}
We evaluated \DSVMP on a PC with an 3.0 GHz Intel Core$^{TM}$ i3 Duo processor and 8GB of RAM.
The PC runs the Windows 10 operating system. We evaluated our approach using four widely use applications, \texttt{md5}, \texttt{aescrypt}, \texttt{bcrypt}, \texttt{gzip}.
We used these applications to process a test text file. The size of the file is 26 KB.
In addition to the four applications, we also evaluate our approach on two interactive gaming applications.
``\texttt{AStar}", a maze pathfinding game using the A* algorithm. ``\texttt{Tetris}" is a classic graphics combination game~\cite{benchmark}.
Figure~\ref{fig:Fig.case} shows the ``\texttt{AStar}" maze barrier setting and route finding results, and the clear row operations of ``\texttt{Tetris}".
In order to be able to facilitate multiple experiments to collect data under the same conditions, we set the barrier of ``\texttt{AStar}" as a rule and easy to construct the shape.
Table~\ref{tab:Tab.3} gives some information of the protected code regions for each benchmark.
The total number of target program instructions are shown in the 3rd column in Table~\ref{tab:Tab.3}.
The 4th column of the table gives the function to be projected
and the 5th column shows the number of instructions of the function.
Finally, we use the Intel Pin tools~\cite{pin} to calculate the number of instructions got executed with the critical functions
while processing the test file, which is shown in the last column of the table.

\begin{table*}[!t]
\scriptsize
\begin{center}
\caption{Information of the benchmarks\label{tab:Tab.3}}
{\tabcolsep8pt\begin{tabular}{@{}rlrclrrl@{}}
\toprule
   & \textbf{program} & \textbf{Size(KB)} & \textbf{Instr. Total} & \textbf{Function to protect} & \textbf{Instr. Protect} & \textbf{Instr. Executed} & \\
\midrule
   & md5 & 11 & 1357 & \texttt{Transform()} & 563 & 229141 & \\
   & aescrypt & 142 & 9788 &\texttt{encrypt-stream()} & 1045 & 478297 & \\
   & bcrypt & 68 & 3081 & \texttt{Blowfish-Encryp()} & 54 & 1050003 & \\
   & gzip & 56 & 9837 & \texttt{deflate()} & 154 & 680037 & \\
   & astar & 281 & 29036 & \texttt{SearchPath()} & 156 & 19589 & \\
   & tetris & 37 & 4386 & \texttt{ClearRow()} & 73 & 10942\\%\footnotemark & \\
\bottomrule
\end{tabular}}{}
\end{center}
Notes: The 3rd column shown the total number of target program instructions. The 4th column of the table gives the function to be projected and the 5th column shows the number of instructions of the function. The number of instructions got executed with the critical functions while processing the test file, and shown in the last column of the table.
\end{table*}
%\footnotetext{For ``\texttt{Tetris}" is doing the clear row operations, the patterns of the whole structure is uncertain, so the number of instructions produced by this action is also uncertain, here we use the average of multiple data.}


\begin{figure}[t]
\centering
\begin{minipage}[t]{0.49\linewidth}
\centering
\includegraphics[width=.9\textwidth]{figure/case2.pdf}
\caption{The interaction interface of the ``\texttt{AStar}" and ``\texttt{Tetris}". In order to be able to facilitate multiple experiments to collect data under the same conditions, we set the barrier of ``\texttt{AStar}" as a rule and easy to construct the shape.}\label{fig:Fig.case}
\end{minipage}
\hspace{0.005\textwidth}
\begin{minipage}[t]{0.49\linewidth}
\centering
\includegraphics[width=.9\textwidth]{figure/codesize.pdf}
\caption{The impact of code sizes for \DSVMP configurations with a different number of VMs. The number of horizontal axis is the configuration of the VMs, ``0" is the original program.}\label{fig:Fig.size}
\end{minipage}
\end{figure}

\subsection{Code Size and Runtime Overhead}\label{sec:benchmarktest}
\subsubsection{Code size}
For each target benchmark, we will choose a core function to protect. 
Only need to do a simple processing for the source code of target benchmark, 
insert a set of specific SDK (``STARTSDK" and ``ENDSDK") at the beginning and end of the key function. 
After the compiler, \DSVMP can accurately locate the key code segment in the executable file.  
we applied \DSVMP to the target function and repeated the process for 10 times.
For each protection run, we used a different number of VM configuration.

Figure~\ref{fig:Fig.size} shows how the \DSVMP multi-VM scheme affects the code size.
As described before, each VM has two bytecode instruction sets and one set of handlers,
the code size of the protected program grows as the number of VM increases.
In general, the code size grows as the number of VMs increases, because the block of PE executables
are usually follow a certain alignment value (such as, 4096 or 512)~\cite{pe}.
Moreover, we can see that there is a strong correlation between the code size of and the number of protected instructions.
This is why the code size of ``\texttt{aescrypt}" grows fastest than others -- as it has
the largest number of protected instructions (see Table~\ref{tab:Tab.3}).
For the same reason, the code size of ``\texttt{bcrypt}" grows slower than other programs,
as this benchmark has the least number of protected instructions.
However, overall the code size growth (a few hundreds KB in our experiments) is modest as typically we only need
to protect the core function or algorithm of the application.

\begin{figure}[t]
\centering
\subfigure[]{
\includegraphics[width=0.485\textwidth]{figure/runtime1.pdf}}
\subfigure[]{
\includegraphics[width=0.485\textwidth]{figure/runtime2.pdf}}
\caption{The average runtime of target benchmark when protected with different VMs. The number of horizontal axis is the configuration of the VMs, ``0" is the original program. Because the runtime overhead of ``\texttt{AStar}" and ``\texttt{Tetris}" is much smaller than the other four benchmarks, in particular, their experimental data are shown separately in (b) in order to observe their variation.}\label{fig:Fig.time}
\end{figure}

\subsubsection{Runtime overhead}

To evaluate the runtime overhead of \DSVMP, we used benchmark to process the test file.
For each protected benchmark we repeated the process for 10 times and report the average runtime per benchmark.
For ``\texttt{AStar}" and ``\texttt{Tetris}", in order to eliminate the user interaction delay,
we only calculate and collect the average runtime of the target operations (pathfinding and row clear).

The results are depicted in Figure~\ref{fig:Fig.time}. We see an increase on the runtime overhead when
using multiple VMs but the overhead becomes stable from 3 VMs onward.
which shows that the majority of average runtime.
%This phenomenon is inevitable, the increase in the number of VMs leads to a
%greater likelihood and diversity of handler's choice, when interpret the virtual instructions.
%It does not add a lot of extra operations to the core function implementation.
Except for the handler's normal interpretation of the time spent on the execution,
the main runtime overhead comes from the the switch time between different VMs.
%and the execution difference \FIXME{what do you mean by execution difference?} of obfuscated handler.
The overhead of VM switch is stable so that it does not significantly increase when
using 3 or more VMs. We notice that the overhead of VM switch for using two VMs
is not significant. This is because our scheme does not frequently switch
the VM under a 2-VM configuration.
Besides, we found that the greater the number of protected instructions get executed at runtime
the greater the runtime overhead will be.
This explains why ``\texttt{bcrypt}" has a much higher runtime overhead than other benchmarks.

%There is also an unique observation that compared to other protection strategies,
%2-VM increase in running time overhead is not obvious.
%This is due to the fact that the random policy we are using does not frequently switch VM in a 2-VM configuration.
%Therefore, its impact on time overhead will not be obvious.
%We have done the relevant test experiments to validate it, see Section~\ref{sec:s-d} for details.


%\paragraph*{Discussion}
%Comprehensively assess the experimental results of several target benchmarks in table~\ref{tab:Tab.3}.
%We find the temporal and spatial overhead of the target program is mainly affected by
%the size of the key code and the number of instructions at execution time.
%So we have reason to believe, if we only focus on protecting a few critical code regions,
%\DSVMP will not cause too much impact on the temporal and spatial overhead of the target program.
%Such as ``\texttt{AStar}" and ``\texttt{Tetris}", a few milliseconds of time overhead for the user is almost impossible to feel.


\subsection{Structural diversity}\label{sec:s-d}
\subsubsection{Multi-VM switching experiment}
In order to evaluate the impact of multi-VM switching on program execution, we conduct experiments on
a small micro-benchmark, ``\texttt{test.exe}\footnote{A 3KB application that pops up a confirmation box.}. Here we only protect one instruction ``\texttt{mov eax, 1234567}" of the application.
So as to reduce the complexity of the protected program as much as possible to facilitate the tracking procedures.
We use three VM configurations, 2-VM, 3-VM and 4-VM to protect the target program.
For each configuration, we run the program execution 5 times to collect the relevant information.


\begin{figure}[t]
\centering
\begin{minipage}[t]{0.49\linewidth}
\centering
\includegraphics[width=.9\textwidth]{figure/testinfor.pdf}
\caption{The probability distribution of multiple VMs switching for multiple runs. ``Switch" is the number of times the VM switch, and ``No Switch" is the opposite.}\label{fig:Fig.testinfor}
\end{minipage}
\hspace{0.005\textwidth}
\begin{minipage}[t]{0.49\linewidth}
\centering
\includegraphics[width=.9\textwidth]{figure/testinstr.pdf}
\caption{The number of instructions changes across runs due to the VM switch.} \label{fig:Fig.testinstr}
\end{minipage}
\end{figure}



Figure~\ref{fig:Fig.testinfor} shows the VM switching frequency information of ``\texttt{test.exe}" for the five runs.
%A total of 69 handler scheduling  the test key instruction functions.
We observe that the frequency of VM switching is low when 2 VMs are use.
However, the frequency increases by 75\% when 3 or 4 VMs are used.
In this experiment, we did not perform handler obfuscation and used only one dispatcher in the protection process.
This can minimize the impact of irrelevant factors os that only the multi-VM switcher can affect the number of instruction executed.
Through the experiment we found that the impact of 2-VM on the number of instructions gets executed at runtime is less than 3-VM and 4-VM,
This is depicted in Figure~\ref{fig:Fig.testinstr}.
Essentially, the number of instructions gets executed can reflect the runtime overhead,
This explains why the 2-VM configuration has a smaller effect on runtime overhead in Figure~\ref{fig:Fig.time}.



\subsubsection{Perform path runtime diversity}
In the course of the above experiment, we also collected the ID of the VM where the handler was executed each time.
Figure~\ref{fig:Fig.execvm} shows the switching of the VM for three runs.
The data in (a) and (b) are from the test program with 3-VM and 4-VM configurations, respectively.

\begin{figure}[t]
\centering
\subfigure[]{
\includegraphics[width=0.485\textwidth]{figure/exec3vm.pdf}}
\subfigure[]{
\includegraphics[width=0.485\textwidth]{figure/exec4vm.pdf}}
\caption{Dynamic VM switching for executing protected code regions. There are a total of 69 handler schedules.
The y-axis shows the VM selected in each schedule. Different lines show the VM switches across runs for a 3-VM (a) and a 4-VM configuration.}\label{fig:Fig.execvm}
\end{figure}

As can be clearly seen in the figure, VMs are randomly selected across different runs,
and the execution path of the 3 runs is not the identical.
For each dispatch loop, the dispatcher will randomly selects a VM to enter and schedules the corresponding handler.
As mentioned before, the handlers set in each VM is obfuscated with different obfuscation schemes
and further performs out-of-order operations.
Thus, the internal structure of the handler dispatched from different VMs at each run times is different.
%As explained in Section~\ref{sec:mvm}, the set of handlers in each VM is obfuscated with different obfuscation methods and is combined in an out-of-order manner. Therefore, the structure of the called Handler is different for the same phase of the different runs. \FIXME{What???} Take the 4-VM configuration as an example, there are a total of 69 handler schedules, regardless of the middle of the dispatcher changes in the process, only the Handler scheduling execution there is $4^{69}$ different execution path. This value is very large, and it will be great resistance to the adversary who use cumulative attacks. \FIXME{Have no idea of what is talking about here. Please make triple check the writing.}
The experimental results show that the execution path of a protected program exhibit strong diversity.
Combined with various handler sets, the target program protected by \DSVMP will have temporal diversity~\cite{4collberg}.
Therefore, our approach can effectively resist the cumulative attacks.


\subsection{Comparisons with state-of-the-arts}\label{sec:comparetest}
We also compared \DSVMP against two commercial VM protection systems,
Code Virtualizer (CV)~\cite{2CV} and VMProtect (VMP)~\cite{3Vmprotect}, in terms of code sizes and runtime overhead.
We adopt a customize protection scheme when using the CV to protect the target program,
which has \emph{Medium} opcodes obfuscation and VM complexity,
and remove the ``Strip Relocation", ``Re-Virtualization" and other additional technology.
So, such a CV has a moderate temporal and spatial overhead.
In addition, we also adopt the VMP with two kinds of schemes to protect the target program,
\emph{Maximum-protection} and \emph{Maximum-speed},
they are respectively the protection effect of the strongest and performance impact of the smallest protection schemes.
For \DSVMP, We used a configuration of 5 VMs, \DSVMP-5VM, in this experiment.
Because the time spent in this configuration has stabilized, and spatial overhead of 5-VM configuration is moderate.

\begin{figure}[t]%
    \centering
    \includegraphics[width=0.8\columnwidth]{figure/comsize.pdf}
    \caption{The comparison of impact on file size with VMProtect and Code Virtualizer.}\label{fig:Fig.com-size}
\end{figure}

\subsubsection{Code size}
Figure \ref{fig:Fig.com-size} shows the impact on code size of several VM-based protection systems.
From the figure we can see that the effects of \DSVMP and commercial VM-based protection systems on code size are similar.
Such as, for the least affected program \texttt{bcrypt}, the \DSVMP-5VM's spatial overhead is 135\%.
The largest overhead is 139\% from the CV, and the average spatial overhead is 134.9\%.
And for the most affected program \texttt{aescrypt}, the spatial overhead of \DSVMP-5VM is 177\%,
and the largest overhead is 252\% which is caused by VMProtect, and the average spatial overhead is 182.5\%.
The growth of the code size is mainly affected by the size of the protected instructions.
The larger the target code to be protected, the large the code size will be.
Among them, the \texttt{aescrypt} has a greater code bloat after protected by VMProtect Maximum-protection,
it may be caused by the complexity of the function \texttt{encrypt-stream()} and the Maximum-protection strategy.
Overall, our approach does not significantly increase the code size when compared to the commercial products.

\begin{figure}[t]%
    \centering
    \includegraphics[width=0.8\columnwidth]{figure/comtime.pdf}
    \caption{The comparison of average runtime overhead with VMProtect and Code Virtualizer.}\label{fig:Fig.com-time}
\end{figure}

\begin{table*}[!t]
\scriptsize
\begin{center}
\caption{The average runtime overhead\label{tab:Tab.4}}
{\tabcolsep8pt\begin{tabular}{@{}rlrrrrrl@{}}
\toprule
   \multicolumn{2}{c}{} & \multicolumn{6}{c}{\textbf{Average runtime(ms)}} \\
   & \textbf{program} & \textbf{Original} & \tabincell{c}{\textbf{DSVMP}\\\textbf{5VM}} & \tabincell{c}{\textbf{VMP}\\\textbf{Max-Speed}} & \tabincell{c}{\textbf{VMP}\\\textbf{Max-Protect}} & \tabincell{c}{\textbf{Code}\\\textbf{Virtualizer}} & \\
\midrule
   & md5      & 1.603 & 64.229  & 73.660  & 141.179  & 803.302  & \\
   & aescrypt & 6.550 & 154.720 & 257.718 & 1903.458 & 623.452  & \\
   & bcrypt   & 4.544 & 298.415 & 252.655 & 1899.968 & 2051.708 & \\
   & gzip     & 3.963 & 169.107 & 368.599 & 1923.022 & 1110.598 & \\
   & astar    & 8.806 & 16.992  & 18.210  & 91.691   & 58.705   & \\
   & tetris   & 0.668 & 1.565   & 4.811   & 13.393   & 12.012   & \\
\midrule
   & Average  & 4.357 & 117.505 & 162.609 & 995.452  & 776.630  & \\
\bottomrule
\end{tabular}}{\\Notes: The average data for the last row is the average runtime for 6 benchmarks for each protection scheme.}
\end{center}
\vspace{-5mm}
\end{table*}

\subsubsection{Runtime overhead} The average runtime overhead of the three schemes is given in Figure \ref{fig:Fig.com-time} which shows that the runtime overhead of \DSVMP and VMProtect Maximum-speed
are comparable and smaller than Code Virtualizer and VMProtect Maimum-protection.
Code protected under CV and VMProtect Maimum-protection has the most expensive runtime overhead,
which on average is higher than \DSVMP and VMProtect Maimum-speed.
Detailed experimental data are shown in Table~\ref{tab:Tab.4}.
We can see from the average runtime data for 6 benchmarks on the last line,
the runtime overhead brings by CV and VMP-Max-Protection are 7 and 9 times bigger than DSVMP-5VM respectively.

%  A & \tabincell{l}{\texttt{mov eax,ebx}\\ \texttt{sub eax,03}} & A' & 23 & 5 & 46 & 18\\
%\paragraph*{Discussion} Through the above analysis and comparison, we argue that the temporal and spatial overhead of our \DSVMP are acceptable.


\section{Related Work}\label{sec:work}
Early work on the binary code protection relies on simple encryption and obfuscation methods,
but they are vulnerable to the sophisticated, diversified attacks developed over the past years.
Traditionally, techniques like junk instructions~\cite{23linn2003obfuscation}, packers~\cite{25Execryptor,26upx},
are used to protect software against attacks based on disassembly and static analysis.
There are also other code protection techniques like code obfuscation~\cite{25wu2010mimimorphism},
control flow and data flow obfuscation~\cite{13liem2008compiler,27ge2005control,27balachandran2014function},
all aim to obfuscate the semantic and logical information of the target program.
In practice, these approaches are often used in combination to provide stronger protection.
\DSVMP also leverages some of the code obfuscation techniques developed in the past for code protection.

There is a growing interest in using code virtualization to protect software from malicious reverse engineering.
Fang \emph{et al.}~\cite{5fang2011multi} proposed a protection scheme based on multi-stage code obfuscation.
Their approach iteratively transforms the critical code region several times with different interpretation methods to improve security.
Yang \emph{et al.}~\cite{6ming2011software} presented a nested virtual machine for code protection.
Using their approach, an adversary would have to fully reverse engineer a layer of the interpreter before moving to the next layer,
which increases the cost of attacks.
Averbuch \emph{et al.}~\cite{27averbuch2011efficient} introduces an encryption and decryption technology
on the basis of VM-based protection. This approach uses the AES algorithm and a customize encryption key
to encrypt the virtual instructions. During runtime, the VM will decrypt the virtual instruction and then
dispatch a handler to interpret the virtual instructions.
Wang \emph{et al.}~\cite{7wang2014tdvmp} proposed a protection scheme to increase the time diversity of protected code regions.
This is achieved by constructing several equivalent but different forms of sub program execution paths,
from which a path will be randomly selected to execute at runtime.

In recent years there are some deobfuscation methods have been proposed.
Coogan \emph{et al.}~\cite{coogan2011deobfuscation} puts forward a behavior based analysis method to analyze the important behavior of code, but it does not pay attention to how to restore the original code structure.
Sharif \emph{et al.}~\cite{sharif2009automatic} used dynamic data-flow and taint analysis to identify data and extract the syntactic and semantic information about the bytecode instructions.
Yadegari \emph{et al.}~\cite{Yadegari2015A}, by tracking the flow of inputs values, and then use semantics-preserving code transformations to simplify the logic of the instructions.
These approach, however, can not restore the structure of the original code completely, and needed taint analysis to get the data flow.

As a departure from prior work, \DSVMP presents a dynamic scheduling structure to improve security for software.
\DSVMP has integrated several novel techniques to increase the diversity and uncertainly of program execution.
These include using a control unit to diversify the execution path of bytecode handlers and using multiple VMs
and dispatchers to randomly schedule instructions from multiple bytecode instruction sets.
Integrating these techniques allows \DSVMP to provide a more diverse program execution structure compared to prior work in the area.
This richer set of diversity can better protect software against code reverse engineering~\cite{20larsen2014sok}.


\section{Conclusions}\label{sec:con}
This paper has presented \DSVMP, a novel VM-based code protection scheme.
\DSVMP uses a dynamic scheduling structure and multiple VMs to increase
diversity of program execution. We have shown that code
segments protected by \DSVMP rarely follow the same execution path across
different runs. The dynamic program execution brought by \DSVMP forces the attacker
to have to use many trail runs to uncover the implementation of the protected code
region. As such, \DSVMP significantly increases the overhead and effort
involved in code reverse engineering. We have evaluated \DSVMP using four
real world applications and compared it to two state-of-the-art VM-based code
protection schemes. Our experimental results show that \DSVMP provide
stronger protection with comparable overhead of runtime and code size.

\section*{Acknowledgment}
This work was partial supported by projects of the National Natural Science Foundation of China
(No. 61373177, No. 61572402, No. 61672427),
the Key Project of Chinese Ministry of Education (No. 211181),
the International Cooperation Foundation of Shaanxi Province, China (No. 2013KW01-02, No. 2015KW-003, No. 2016KW-034),
the China Postdoctoral Science Foundation (grant No. 2012M521797),
the Research Project of Shaanxi Province Department of Education (No. 15JK1734),
the Research Project of NWU, China (No. 14NW28),
and the UK Engineering and Physical Sciences Research Council under grants EP/M01567X/1 (SANDeRs), EP/M015793/1 (DIVIDEND).



%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%\appendix

%\section{Section in Appendix}
%\label{appendix-sec1}

%% References
%%
%% Following citation commands can be used in the body text:
%% Usage of \cite is as follows:
%%   \cite{key}         ==>>  [#]
%%   \cite[chap. 2]{key} ==>> [#, chap. 2]
%%

%% References with bibTeX database:

\bibliographystyle{elsarticle-num}
% \bibliographystyle{elsarticle-harv}
% \bibliographystyle{elsarticle-num-names}
% \bibliographystyle{model1a-num-names}
% \bibliographystyle{model1b-num-names}
% \bibliographystyle{model1c-num-names}
% \bibliographystyle{model1-num-names}
% \bibliographystyle{model2-names}
% \bibliographystyle{model3a-num-names}
% \bibliographystyle{model3-num-names}
% \bibliographystyle{model4-names}
% \bibliographystyle{model5-names}
% \bibliographystyle{model6-num-names}

\bibliography{reference}


\end{document}

%%
%% End of file `elsarticle-template-num.tex'.
